import { c as stringToHeaders, j as jsonParse, l as listToHeaders } from './fetch-deps.js';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

function parseContentHeaders(headersString) {
    var _a, _b;
    const headers = stringToHeaders(headersString);
    const contentType = headers.get('content-type') || 'text/plain';
    const disposition = headers.get('content-disposition');
    if (!disposition) {
        throw new Error('"Content-Disposition" header is required.');
    }
    const directives = disposition.split(';').reduce((acc, chunk) => {
        const [name, ...rest] = chunk.trim().split('=');
        acc[name] = rest.join('=');
        return acc;
    }, {});
    const name = (_a = directives.name) === null || _a === void 0 ? void 0 : _a.slice(1, -1);
    const filename = (_b = directives.filename) === null || _b === void 0 ? void 0 : _b.slice(1, -1);
    return {
        name,
        filename,
        contentType,
    };
}
/**
 * Parses a given string as a multipart/form-data.
 * Does not throw an exception on an invalid multipart string.
 */
function parseMultipartData(data, headers) {
    const contentType = headers === null || headers === void 0 ? void 0 : headers.get('content-type');
    if (!contentType) {
        return undefined;
    }
    const [, ...directives] = contentType.split('; ');
    const boundary = directives
        .filter((d) => d.startsWith('boundary='))
        .map((s) => s.replace(/^boundary=/, ''))[0];
    if (!boundary) {
        return undefined;
    }
    const boundaryRegExp = new RegExp(`--+${boundary}`);
    const fields = data
        .split(boundaryRegExp)
        .filter((chunk) => chunk.startsWith('\r\n') && chunk.endsWith('\r\n'))
        .map((chunk) => chunk.trimStart().replace(/\r\n$/, ''));
    if (!fields.length) {
        return undefined;
    }
    const parsedBody = {};
    try {
        for (const field of fields) {
            const [contentHeaders, ...rest] = field.split('\r\n\r\n');
            const contentBody = rest.join('\r\n\r\n');
            const { contentType, filename, name } = parseContentHeaders(contentHeaders);
            const value = filename === undefined
                ? contentBody
                : new File([contentBody], filename, { type: contentType });
            const parsedValue = parsedBody[name];
            if (parsedValue === undefined) {
                parsedBody[name] = value;
            }
            else if (Array.isArray(parsedValue)) {
                parsedBody[name] = [...parsedValue, value];
            }
            else {
                parsedBody[name] = [parsedValue, value];
            }
        }
        return parsedBody;
    }
    catch (error) {
        return undefined;
    }
}

/**
 * Parses a given request/response body based on the `Content-Type` header.
 */
function parseBody(body, headers) {
    if (body) {
        const contentType = headers === null || headers === void 0 ? void 0 : headers.get('content-type');
        // If the body has a Multipart Content-Type
        // parse it into an object.
        const hasMultipartContent = contentType === null || contentType === void 0 ? void 0 : contentType.startsWith('multipart/form-data');
        if (hasMultipartContent && typeof body !== 'object') {
            return parseMultipartData(body, headers) || body;
        }
        // If the intercepted request's body has a JSON Content-Type
        // parse it into an object.
        const hasJsonContent = contentType === null || contentType === void 0 ? void 0 : contentType.includes('json');
        if (hasJsonContent && typeof body !== 'object') {
            return jsonParse(body) || body;
        }
        // Otherwise leave as-is.
        return body;
    }
    // Return whatever falsey body value is given.
    return body;
}

/**
 * Formats a mocked request for introspection in browser's console.
 */
function prepareRequest(req) {
    return Object.assign(Object.assign({}, req), { headers: req.headers.getAllHeaders() });
}

/**
 * Formats a mocked response for introspection in browser's console.
 */
function prepareResponse(res) {
    const responseHeaders = listToHeaders(res.headers);
    return Object.assign(Object.assign({}, res), { 
        // Parse a response JSON body for preview in the logs
        body: parseBody(res.body, responseHeaders) });
}

function getTimestamp() {
    const now = new Date();
    return [now.getHours(), now.getMinutes(), now.getSeconds()]
        .map(String)
        .map((chunk) => chunk.slice(0, 2))
        .map((chunk) => chunk.padStart(2, '0'))
        .join(':');
}

/**
 * Returns a HEX color for a given response status code number.
 */
function getStatusCodeColor(status) {
    if (status < 300) {
        return '#69AB32';
    }
    if (status < 400) {
        return '#F0BB4B';
    }
    return '#E95F5D';
}

/**
 * Converts a string path to a Regular Expression.
 * Transforms path parameters into named RegExp groups.
 */
const pathToRegExp = (path) => {
    const pattern = path
        // Escape literal dots
        .replace(/\./g, '\\.')
        // Escape literal slashes
        .replace(/\//g, '/')
        // Escape literal question marks
        .replace(/\?/g, '\\?')
        // Ignore trailing slashes
        .replace(/\/+$/, '')
        // Replace wildcard with any zero-to-any character sequence
        .replace(/\*+/g, '.*')
        // Replace parameters with named capturing groups
        .replace(/:([^\d|^\/][a-zA-Z0-9_]*(?=(?:\/|\\.)|$))/g, (_, paramName) => `(?<${paramName}>[^\/]+?)`)
        // Allow optional trailing slash
        .concat('(\\/|$)');
    return new RegExp(pattern, 'gi');
};

/**
 * Matches a given url against a path.
 */
const match = (path, url) => {
    const expression = path instanceof RegExp ? path : pathToRegExp(path);
    const match = expression.exec(url) || false;
    // Matches in strict mode: match string should equal to input (url)
    // Otherwise loose matches will be considered truthy:
    // match('/messages/:id', '/messages/123/users') // true
    const matches = path instanceof RegExp ? !!match : !!match && match[0] === match.input;
    return {
        matches,
        params: match && matches ? match.groups || null : null,
    };
};

var getCleanUrl_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCleanUrl = void 0;
/**
 * Removes query parameters and hashes from a given URL.
 */
function getCleanUrl(url, isAbsolute) {
    if (isAbsolute === void 0) { isAbsolute = true; }
    return [isAbsolute && url.origin, url.pathname].filter(Boolean).join('');
}
exports.getCleanUrl = getCleanUrl;

});

/**
 * Returns an absolute URL based on the given relative URL, if possible.
 * Ignores regular expressions.
 */
const getAbsoluteUrl = (mask) => {
    // Global `location` object doesn't exist in Node.
    // Relative request predicate URL cannot become absolute.
    const hasLocation = typeof location !== 'undefined';
    return typeof mask === 'string' && mask.startsWith('/')
        ? `${hasLocation ? location.origin : ''}${mask}`
        : mask;
};

/**
 * Converts a given request handler mask into a URL, if given a valid URL string.
 */
function getUrlByMask(mask) {
    /**
     * If a string mask contains an asterisk (wildcard), return it as-is.
     * Converting a URL-like path string into an actual URL is misleading.
     * @see https://github.com/mswjs/msw/issues/357
     */
    if (mask instanceof RegExp || mask.includes('*')) {
        return mask;
    }
    try {
        // Attempt to create a URL instance out of the mask string.
        // Resolve mask to an absolute URL, because even a valid relative URL
        // cannot be converted into the URL instance (required absolute URL only).
        return new URL(getAbsoluteUrl(mask));
    }
    catch (error) {
        // Otherwise, the mask is a path string.
        return mask;
    }
}

function getCleanMask(resolvedMask) {
    return resolvedMask instanceof URL
        ? getCleanUrl_1.getCleanUrl(resolvedMask)
        : resolvedMask instanceof RegExp
            ? resolvedMask
            : getAbsoluteUrl(resolvedMask);
}

/**
 * Returns the result of matching given request URL
 * against a mask.
 */
function matchRequestUrl(url, mask) {
    const resolvedMask = getUrlByMask(mask);
    const cleanMask = getCleanMask(resolvedMask);
    const cleanRequestUrl = getCleanUrl_1.getCleanUrl(url);
    return match(cleanMask, cleanRequestUrl);
}

/**
 * Return the stack trace frame of a function's invocation.
 */
function getCallFrame() {
    const frames = new Error().stack.split('\n');
    // Get the first frame that doesn't reference the library's internal trace.
    // Assume that frame is the invocation frame.
    const ignoreFrameRegExp = /(node_modules)?[\/\\]lib[\/\\](umd|esm|iief|cjs)[\/\\]|^[^\/\\]*$/;
    const declarationFrame = frames.slice(1).find((frame) => {
        return !ignoreFrameRegExp.test(frame);
    });
    if (!declarationFrame) {
        return;
    }
    // Extract file reference from the stack frame.
    const declarationPath = declarationFrame
        .replace(/\s*at [^()]*\(([^)]+)\)/, '$1')
        .replace(/^@/, '');
    return declarationPath;
}

export { commonjsGlobal as a, getCallFrame as b, createCommonjsModule as c, prepareRequest as d, prepareResponse as e, getTimestamp as f, getUrlByMask as g, getStatusCodeColor as h, matchRequestUrl as m, parseBody as p };
